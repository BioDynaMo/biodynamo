// kernel displacement_op_opencl_kernel start 
// kernel stringified at 2018-03-09 13:03

#ifndef DISPLACEMENT_OP_OPENCL_KERNEL_H_
#define DISPLACEMENT_OP_OPENCL_KERNEL_H_

const char* const displacement_op_opencl_kernel = "double norm(double3 v) {\n"
"  return sqrt(v.x*v.x + v.y*v.y + v.z*v.z);\n"
"}\n"
"\n"
"double squared_euclidian_distance(__global double* positions, uint idx, uint nidx) {\n"
"  const double dx = positions[3*idx + 0] - positions[3*nidx + 0];\n"
"  const double dy = positions[3*idx + 1] - positions[3*nidx + 1];\n"
"  const double dz = positions[3*idx + 2] - positions[3*nidx + 2];\n"
"  return (dx * dx + dy * dy + dz * dz);\n"
"}\n"
"\n"
"int3 get_box_coordinates(double3 pos, __constant int* grid_dimensions, uint box_length) {\n"
"  int3 box_coords;\n"
"  box_coords.x = (floor(pos.x) - grid_dimensions[0]) / box_length;\n"
"  box_coords.y = (floor(pos.y) - grid_dimensions[1]) / box_length;\n"
"  box_coords.z = (floor(pos.z) - grid_dimensions[2]) / box_length;\n"
"  return box_coords;\n"
"}\n"
"\n"
"int3 get_box_coordinates_2(uint box_idx, __constant uint* num_boxes_axis_) {\n"
"  int3 box_coord;\n"
"  box_coord.z = box_idx / (num_boxes_axis_[0]*num_boxes_axis_[1]);\n"
"  uint remainder = box_idx % (num_boxes_axis_[0]*num_boxes_axis_[1]);\n"
"  box_coord.y = remainder / num_boxes_axis_[0];\n"
"  box_coord.x = remainder % num_boxes_axis_[0];\n"
"  return box_coord;\n"
"}\n"
"\n"
"uint get_box_id_2(int3 bc,__constant uint* num_boxes_axis) {\n"
"  return bc.z * num_boxes_axis[0]*num_boxes_axis[1] + bc.y * num_boxes_axis[0] + bc.x;\n"
"}\n"
"\n"
"uint get_box_id(double3 pos, __constant uint* num_boxes_axis, __constant int* grid_dimensions, uint box_length) {\n"
"  int3 box_coords = get_box_coordinates(pos, grid_dimensions, box_length);\n"
"  return get_box_id_2(box_coords, num_boxes_axis);\n"
"}\n"
"\n"
"void compute_force(__global double* positions, __global double* diameters, uint idx, uint nidx, double3* collision_force) {\n"
"  double r1 = 0.5 * diameters[idx];\n"
"  double r2 = 0.5 * diameters[nidx];\n"
"  // We take virtual bigger radii to have a distant interaction, to get a desired density.\n"
"  double additional_radius = 10.0 * 0.15;\n"
"  r1 += additional_radius;\n"
"  r2 += additional_radius;\n"
"\n"
"  double comp1 = positions[3*idx + 0] - positions[3*nidx + 0];\n"
"  double comp2 = positions[3*idx + 1] - positions[3*nidx + 1];\n"
"  double comp3 = positions[3*idx + 2] - positions[3*nidx + 2];\n"
"  double center_distance = sqrt(comp1 * comp1 + comp2 * comp2 + comp3 * comp3);\n"
"\n"
"  // the overlap distance (how much one penetrates in the other)\n"
"  double delta = r1 + r2 - center_distance;\n"
"\n"
"  if (delta < 0) {\n"
"    return;\n"
"  }\n"
"\n"
"  // to avoid a division by 0 if the centers are (almost) at the same location\n"
"  // TODO(ahmad): change this to random values\n"
"  if (center_distance < 0.00000001) {\n"
"    collision_force->x += 42.0;\n"
"    collision_force->y += 42.0;\n"
"    collision_force->z += 42.0;\n"
"    return;\n"
"  }\n"
"\n"
"  // the force itself\n"
"  double r = (r1 * r2) / (r1 + r2);\n"
"  double gamma = 1; // attraction coeff\n"
"  double k = 2;     // repulsion coeff\n"
"  double f = k * delta - gamma * sqrt(r * delta);\n"
"\n"
"  double module = f / center_distance;\n"
"  collision_force->x += module * comp1;\n"
"  collision_force->y += module * comp2;\n"
"  collision_force->z += module * comp3;\n"
"  // printf(\"collision_force = (%f, %f, %f)\\n\", collision_force->x, collision_force->y, collision_force->z);\n"
"}\n"
"\n"
"\n"
"void default_force(__global double* positions,\n"
"                   __global double* diameters,\n"
"                   uint idx, uint start, ushort length,\n"
"                   __global uint* successors, double squared_radius,\n"
"                   double3* collision_force) {\n"
"  uint nidx = start;\n"
"\n"
"  for (ushort nb = 0; nb < length; nb++) {\n"
"    // implement logic for within radius here\n"
"    if (nidx != idx) {\n"
"      if (squared_euclidian_distance(positions, idx, nidx) < squared_radius) {\n"
"        compute_force(positions, diameters, idx, nidx, collision_force);\n"
"      }\n"
"    }\n"
"    // traverse linked-list\n"
"    nidx = successors[nidx];\n"
"  }\n"
"}\n"
"\n"
"__kernel void collide(__global double* positions,\n"
"                      __global double* diameters,\n"
"                      __global double* tractor_force,\n"
"                      __global double* adherence,\n"
"                      __global uint* box_id,\n"
"                      __global double* mass,\n"
"                      double timestep,\n"
"                      double max_displacement,\n"
"                      double squared_radius,\n"
"                      uint N,\n"
"                      __global uint* starts,\n"
"                      __global ushort* lengths,\n"
"                      __global uint* successors,\n"
"                      uint box_length,\n"
"                      __constant uint* num_boxes_axis,\n"
"                      __constant int* grid_dimensions,\n"
"                      __global double* result) {\n"
"  uint tidx = get_global_id(0);\n"
"  if (tidx < N) {\n"
"    // Apply tractor forces\n"
"    result[3*tidx + 0] = timestep * tractor_force[3*tidx + 0];\n"
"    result[3*tidx + 1] = timestep * tractor_force[3*tidx + 1];\n"
"    result[3*tidx + 2] = timestep * tractor_force[3*tidx + 2];\n"
"    // printf(\"cell_movement = (%f, %f, %f)\\n\", result[3*tidx + 0], result[3*tidx + 1], result[3*tidx + 2]);\n"
"\n"
"    double3 collision_force = (double3)(0, 0, 0);\n"
"\n"
"    // Moore neighborhood\n"
"    int3 box_coords = get_box_coordinates_2(box_id[tidx], num_boxes_axis);\n"
"    for (int z = -1; z <= 1; z++) {\n"
"      for (int y = -1; y <= 1; y++) {\n"
"        for (int x = -1; x <= 1; x++) {\n"
"          uint bidx = get_box_id_2(box_coords + (int3)(x, y, z), num_boxes_axis);\n"
"          if (lengths[bidx] != 0) {\n"
"            default_force(positions, diameters, tidx, starts[bidx], lengths[bidx], successors, squared_radius, &collision_force);\n"
"          }\n"
"        }\n"
"      }\n"
"    }\n"
"\n"
"    // Mass needs to non-zero!\n"
"    double mh = timestep / mass[tidx];\n"
"    // printf(\"mh = %f\\n\", mh);\n"
"\n"
"    if (norm(collision_force) > adherence[tidx]) {\n"
"      result[3*tidx + 0] += collision_force.x * mh;\n"
"      result[3*tidx + 1] += collision_force.y * mh;\n"
"      result[3*tidx + 2] += collision_force.z * mh;\n"
"      // printf(\"cell_movement (1) = (%f, %f, %f)\\n\", result[3*tidx + 0], result[3*tidx + 1], result[3*tidx + 2]);\n"
"\n"
"      if (norm(collision_force) * mh > max_displacement) {\n"
"        result[3*tidx + 0] = max_displacement;\n"
"        result[3*tidx + 1] = max_displacement;\n"
"        result[3*tidx + 2] = max_displacement;\n"
"      }\n"
"    }\n"
"    // printf(\"cell_movement (2) = (%f, %f, %f)\\n\", result[3*tidx + 0], result[3*tidx + 1], result[3*tidx + 2]);\n"
"  }\n"
"}\n"
"\n"
"__kernel void clear_force_opencl(__global double* result, uint N) {\n"
"  uint tidx = get_global_id(0);\n"
"  if (tidx < N * N * N) {\n"
"    result[3*tidx + 0] = 0;\n"
"    result[3*tidx + 1] = 0;\n"
"    result[3*tidx + 2] = 0;\n"
"  }\n"
"}\n"
;
// kernel displacement_op_opencl_kernel end 

#endif  // DISPLACEMENT_OP_OPENCL_KERNEL_H_
